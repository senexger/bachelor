\chapter{Proposed Approach}

Different approaches are presented and discussed in this chapter using data link unicast or broadcast in different specifications,
these were also empirically tested and evaluated in the \cref{sec:evaluation}.
At the end of this chapter, the test setup was introduced and 
it is briefly explained how the chips are programmed and how the measured values were generated and collected.

\section{Design}

The use of high-layer protocols, such as Art-Net \cref{sec:artnet}, in lighting technology involves a considerable overhead. 
Because the lighting console does not talk directly to the \ac{WES}, communication must be controlled via an \ac{AP}, 
which means that the \ac{IP} (layer 3) must be used for addressing and \ac{UDP} (layer 4) for transporting the data. 
They both come withe additional headers. 
Such an overhead can lead to latency, channel congestion and packet loss.
 
In an ad-hoc network \cref{itm:bss}, on the other hand, packets can be sent directly on the MAC (layer 2) \cref{tab:Layer}. 
With a payload of a few bytes to each WES, keeping overheat small can be quite important. 
Complexity problems as often typical in Ad-Hoc networks are not to be assumed, 
since the controller at the light desk must normally stand in line of sight to the individual WES, 
from there finally the lighting technician from there must have everything in the range of vision to be able to intervene. 
One can therefore assume a simple star topology.
In the following the ESP-NOW \cref{sub:espnow} protocol was chosen to distribute the packets low-level, 
because even if it was not developed for this purpose the specification fits quite well to the requirements.

\begin{table}[h]
	\centering
	% \label{tab:layer_overview}
	\begin{tabular} { ccc }
		\begin{tabular}{ |c| } 
			\hline
			Art-Net\\
			\hline
			UDP\\
			\hline
			IP\\
			\hline
			802.11 DL/Unicast\\
			\hline
			802.11* PHY\\ 
			\hline
		\end{tabular}
		\begin{tabular}{ |c| } 
			\hline
			Slim Application\\
			\\
			\\
			\hline
			802.11 DL/UC or BC\\
			\hline
			802.11b/g/n PHY\\ 
			\hline
		\end{tabular}
		% \begin{tabular}{ |c| } 
		% 	\hline
		% 	Slim-Broadcast\\
		% 	\\
		% 	\\
		% 	\hline
		% 	802.11 DL/Broadcast\\
		% 	\hline
		% 	802.11b/g/n PHY\\ 
		% 	\hline
		% \end{tabular}
	\end{tabular}
	\caption{Art-Net Layer compared with Slim Data Link Layer}
	\label{tab:Layer}
\end{table}
\TODO{Fehlt hier nicht ESP-Now?}

For the purpose of this analysis, the controller transmits 20 Byte (analogue to 20 DMX channels) to every WESs.
Four different metrics are considered, which where discussed in the requirements. \todo{ref to requirements}
\begin{itemize}
	\item \textbf{Latency} \\
	What is the latency from commanding the controller to the estimated reaction at the WES e.g. lighting of a light?
	For the sake of simplicity, delays caused by the microcontroller instruction set, data distribution and 
	control of the light installation are neglected and the focus is placed only on the airtime.
	\item \textbf{Update Frequency}\\
	How often can the we update all WESs per second? 
	This results in how smooth movement of moving heads are moving or how smooth the transition of the color of an LED can be performed.
	\item \textbf{Reliability}\\
	Wie sicher kommen die vom Controller gesendeten Daten bei den WESs an?
	Lack of reliability can result 
	in two WESs positioned next to each other not behaving the same because one of them only receives half of the signals.
	\item \textbf{Synchronisation}\\
	Are the signals sent to different WESs carried out at the same time?
	If two of the WESs are to be controlled simultaneously, 
	but the signal was transmitted one after the other, they have to wait for each other so that the lights change at the same time.
\end{itemize}

\subsection{Slim Unicast}

The implementation that probably comes closest to Art-Net's is to replace the TCP packets sent by Art-Net 
to the respective IP-Address of the WESs with unicasts to the MAC-address of the WES.
Of course, the MAC address of all WESs must be known and they must all be paired with the controller, but 
this process is just analogous to  mapping the corresponding IP addresses after dialing the WESs into a WLAN.

\subsubsection*{Latency}

Latency describes the time between a command and the expected response, here considered as airtime.
The airtime using 1Mbit/s is rather easy calculated, every Byte (8 Bits) takes 8$\mu$s.

For a full transmission the PHY and MAC preamble and header be transmitted twice, once for the data and once for the acknowledgement.
The MAC body contains the payload, which depends of the needs of the addressed \ac{WES}.
In a perfect clean channel the sender hasn't to defer, but has to take a \ac{DIFS} plus a backoff.
A perfect empty channel resets the CW to CW$_{min}$, which are 16 slots in 802.11b,
so the average backoff should take $\frac{CW_{min}}{2}$ slots, with a slottime of 20$\mu$s follows an average backoff of 160$\mu$s.

\begin{table}[h]
	\centering
	\begin{tabular} { lrr }
		\toprule
		\multicolumn{1}{c}{Frame segment}
		& \multicolumn{1}{c}{Byte}
		& \multicolumn{1}{c}{Airtime in $\mu$s} \\
		\midrule
		DIFS								& -		& 50 \\
		Average Backoff						& -		& 160 \\
		PHY header: PLCP preamble			& 18	& 144 \\
		PHY header: PLCP header				& 6 	& 48 \\
		MAC headers							& 28	& 224 \\
		MAC body							& 20 	& 160 \\
		\textbf{= tx time data}				& 		& \textbf{746} \\
		SIFS								& -		& 10 \\
		PHY header: PLCP preamble			& 18	& 144 \\
		PHY header: PLCP header				& 6		& 48 \\
		MAC headers, no MAC body	 		& 18	& 112 \\
		\textbf{= tx time ack}				& 		& \textbf{314} \\
		\bottomrule
	\end{tabular}
	\caption{Composition of the Total Airtime (tx + ack)}
	\label{tab:airtime_unicast_calc}
\end{table}

The total airtime of the transmission of data and ack, assuming the transmission arrived successfully, is $t_tx=1100\mu$s.
Strictly speaking, the light could also be changed before the acknolegement is sent, i.e. after 746$\mu$s.
The latency scales linearly, the delay to the n-th WES is:
\begin{align}
	n \cdot t_{tx} = n \cdot 1100\mu s
\end{align}

In order to avoid unnecessary load on the radio channel, Art-Net transmit only the changes.
In the worst case, however, changes affect all WESs at the same time.

\subsubsection*{Update Frequency}
Following the approach of DMX and updating the 'bus' every 44Hz, would made by sending the packets round robin via unicast. 
\todo{Discuss the inimportance of order of round robin in unicast}
With a correspondingly high number of WESs, this could be challenge with a transmission speed of 1MBit/s, 
it also scales linearly with each additional WES. 
In an labor steril empty channel, denying all side latencys, there could be:
\begin{align}
	\frac{1}{n * 1100\mu s} = \frac{9090}{n} Hz
\end{align}

For 10 WESs, addressed with respectively 20 Byte, it would still be 909Hz.
This is far above the update frequency of DMX, but also very unrealistic and just intended to show,
that it could theoretically be within the realm of possibility.

\subsubsection*{Reliability}

One benefit of the unicast is the support of acknoledgements. So the reliability should be very good. 
The idea of the slim unicast is, that a transmission to each device is very fast, because the transmitted payload small.
However, since we are sending many small packets, it can be assumed that we will be sending a lot of overhead.
So we playing off reliability against transmission speed.


\subsubsection{Synchronisation}

\begin{align*} \label{eq:delay_unicast}
	t_{bestcase}  &= N \cdot (t_{frame} + 8 \cdot t_{ack}) \\
	t_{worstcase} &= N \cdot (t_{frame} + 1 \cdot t_{ack})
\end{align*} 

Unfortunately the ESP-Now protocol does not allow to control the number of retransmissions before the packet is discarded.
\todo{Is it tru, that retransmission can't be controlled in ESP-NOW?}

\subsection{Slim Broadcast}
\begin{itemize}
	\item topology
	\item efficiency
	\item for how many nodes it does make theoretical a difference
\end{itemize}

The ESP-Now protocol supports both unicast and broadcast.
Instead of transmitting every unicast after each other, we transmit a broadcast with the payload of all channels at the same time to all fixtures.
If we need more than 250 channel we have to send to broadcasts to transmit all information to all fixtures.
To achieve this we need to tell each fixture in advance his channel.
A fixture with a channel above 250 needs to modulo to get the broadcast ID.

\TODO{Notwendig?}
\begin{align*}
	315 \mod 250 &= 1 \\
	315 / 250 &= 65
\end{align*}

Insead of transmitting to several fixtures after each other we just transmitt to all fixtures at the same time.
This solves the problem of synchronization for less than 250 channel.
For more than 250 each fixture has to wait until the last broadcast is arrived, 
even if he must be discarded because the required channel has already been arrived in a previous broadcast.
Through less overhead there is an estimated difference when a specific amount of fixtures is reached.
\TODO{Grafik die zeigt, wie der Broadcast besser performt, sobald eine bestimmte zahl fixtures erreicht ist}

\begin{figure}
	\centering
	\includegraphics[scale=0.7]{/home/walther/Documents/bachelor/Plot2/Graphs/bc_uc_transmissiontime_analytic.pdf}
	\caption{Transmission Time of Unicast vs Broadcast}
	\label{fig:bc_uc_transmissiontime_analytic}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[scale=0.7]{/home/walther/Documents/bachelor/Plot2/Graphs/bc_analytic.pdf}
	\caption{Transmission Time of Broadcasts Depending on Payload}
	\label{fig:bc_analytic}
\end{figure}

\subsection{Rapid Repetition}
\begin{itemize}
\item simple
\item redundant
\item fast
\item cite paper from tolja
\item explain why its only relevant for BC?
\end{itemize}

The ESP-Now broadcast does not support acknoledgements.
So we can't retransmit a packet to the fixture, which is not arrived successfully.
In case of broadcast we had to transmit the hole broadcast or an unicast to each fixture wich does not send back the acknoledgement.\\

Since this is very cumbersome to implement, it is a good approach to simply repeat each broadcast. 
\TODO{Cite paper A First Implementation and Evaluation of the IEEE 802.11aa Group Addressed Transmission Service}
This is called rapid repetition. \TODO{Is Rapid Repetition a appropriate name? Unsosliced Repetition is better siehe Paper?}
The idea is, that we can push the reliability wich each redundant retransmission.

The estimated reliability of a fixture with average success ratio (SR) of 83\% without Repetition has to be 83\%.
If we increase the number of Rapid Repetitions (RR) we can roughly estimate:
\begin{align}
	% ER &= 1-SR &\text{Errorrate}\\
	SR_{RR}(RR) &= 1-(1-SR)^{RR+1} 
\end{align}
\todo{RR von 0 beginnen}
\TODO{grafische Darstellung RR=[0,1,2,3,4], für einen guten und einen schlechten Knoten 83\% und 95\%}

\begin{figure}
	\centering
	\includegraphics[scale=0.7]{/home/walther/Documents/bachelor/Plot2/Graphs/rr_transmission_time.pdf}
	\caption{Transmission Time with with different \ac{RR}s}
	\label{fig:bc_analytic}
\end{figure}

We have to figure out how many repetitions we should transmit in order to find the best balance between reliability and latency/update ratio.
This hardly correlates with the overall success ratio in the (test-)setup. \TODO{(test-)setup: kann man das so schrieben?}

\subsection{Delayed Repetition}
\label{sub:DelayedRepetition}
\begin{itemize}
\item when to perform repetition
\item buffering delay
\item explain why its only relevant for BC?
\end{itemize}

Therfore is synchronisation of all devices expensive, 
because every fixture has to wait after the successfull receiving of his packet until the last fixture received his packet too.
This is further discussed in \cref{sub:DelayedRepetition}.
\TODO{move to buffering delay??}

To push the idea of rapid repetion even further, we should take a look to temporarily occuring disturbances.
\TODO{Figure of bad channel time}

\section{Implementation}
\begin{itemize}
\item ESP programming
\item code examples
\item python script
\end{itemize}

\todo{for later use: ESP-NOW User Guide, V1, source: \url{https://www.espressif.com/en/support/documents/}}

\subsection{ESP Programming}
\begin{itemize}
\item broadcast unicast
\item IDF/Arduino
\item IDE \& ESP hardware flashing
\item setup devices
\end{itemize}
Unfortunally in the documentation of the ESP-protocol is written, that broadcast is not supported 
% \TODO{link, https:\/\/www.espressif.com\/sites\/default\/files\/documentation\/esp-now_user_guide_en.pdf, 2016}
but actually it is. Insted of adding the \ac{MAC} Address of a fixture, we can use 
\todo{has this a proper name, like broadcast address?} ff:ff:ff:ff:ff:ff 
to add a peer with the broadcast \ac{MAC}.

\label{lst:shorttable}
\begin{lstlisting}
void addFixtureToPeerList(const uint8_t *mac_addr) 
{
	if (esp_now_is_peer_exist(mac_addr)) return;

	peer_info.channel = 1;               // 1-14
	peer_info.ifidx   = ESP_IF_WIFI_STA; // Station mode
	peer_info.encrypt = false;         	 // not needed
	memcpy(peer_info.peer_addr, mac_addr, 6);

	esp_err_t status = esp_now_add_fixture(&peer_info);
	if (ESP_OK != status) 
	{
		Serial.println("[ERROR] Could not add fixture");
	}
	else 
	{
		Serial.println("[OK] fixture added");
	}
}
\end{lstlisting}
% \lstinputlisting[caption=Scheduler, style=customc]{hello.c}

\TODO{fix colorscheme omf code examples}

\subsection{Collecting measurment results}
\begin{itemize}
\item Collecting values
\item state machine
\item python script
\item saving values
\item digital encoding e.g.: 777477472717
\end{itemize}

\begin{figure}
	\includegraphics[scale=0.8]{figures/sequence_diagram.pdf}
	\caption{Sequence diagram of the measurment}
	\label{fig:sequenceDiagram}
\end{figure}

\begin{sequencediagram}
	\newinst{c}{:computer}
	\newthread{t}{:Transmitter}
	\newinst[2]{w}{:WES 1}
	\newinst{n}{:WES n}

	% give test vector to transmitter via serial
	% \begin{call}{c}{testVector()}{t}{ack()}
	\mess{c}{Test Parameter}{t}

	% \begin{sdblock}{}{distribute test parameter}
	\begin{call}{t}{Test Parameter}{w}{ack()}
	\end{call}
	\begin{call}{t}{Test Parameter}{n}{ack()}
	\end{call}
	% \end{sdblock}

	\mess[1]{t}{measurments}{w}
	\mess[1]{t}{measurments}{n}	

	\begin{call}{t}{request measurment}{w}{ack()}
	\end{call}
	\begin{call}{t}{request measurment}{n}{ack()}
	\end{call}
	% \begin{call}{t}{function()}{wn}{ack()}
	% \end{call}
	\mess{t}{Test Results}{c}

\end{sequencediagram}