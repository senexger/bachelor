#+TITLE: Bachelorarbeit ESP-Now as light protocol

[[file:/home/walther/Documents/org-mode/pinnwand.org][Pinnwand]]

Ablauf:
- Slave checkt nach integrity
- slave-master  : need offset, broadcastID; have lenght
- master-slave  : send offset, broadcastID
- master-broad  : send broadcast
- slave         : write extracted input to serial

* LOL Problems
** Verify und Upload verwechselt
** Strom von meinem Hub liefert nicht genug Strom, wenn Tastaturbeleutung eingeschaltet ist
** USB Kabel ist kein Datenkabel
** Chip ist kaputt gegangen
** Power HUB external
works like a charme :)
** Variable wurde nur bei Neustart zurückgesetzt
Weil ich den chip so häufig neu geflasht habe, ist der Fehler nur selten auf getaucht
** Nach Standby sind dev0 und dev1 verstauscht
deswegen wird dann gelegentlich der Master mit Slave code geflasht und andersherum
* FLOW
** Master
- SerialBegin
- InitESPTimer
- pythonBridge
- createMetaPackage
- setup
  a. setupBroadcast
  b. setupUnicast
- sending
  a. sendBroadcast
  b. sendUnicast
** Slave (onDataReceive)
1. memcpy
   a. applyMetaInformation
   b. checkDataPayload
2. Timestamp
* DONE Broadcast
Broadcasting just works fine. But I need a good solution, if I will transmit more than one universer at once.
Now I will try to send Messages as Slave and receive as Master. So the Slave tells the Master how many bytes he needs (via unicast) and the Master talks back his position.
After this I have to check, with a lot of nodes to transmit two universes. There has to be a checksum in the beginning.
Maybe its more easy to send a part of the Mac of each fixture, and the number of used channels. There is to calculate the lost traffic.
Optional: In the ideal case, the master splits all Broadcasts in same sized packages.
- [X] Unicast
- [X] Tolja schreiben!
- [X] Unicast reparieren
* DONE Konferenz mit Toja
  + [X] Delay damit ESP nicht abraucht
  + [X] Theorie Hybrid Wireles Mesh Protocol Metrik
    - [X] geeignete Metrik?
    - [X] wie Dauer messen? Im Slave oder Master, Ausgabe via Serial ok?
    - [X] PER?
    - [X] Bitte die Formeln für die resultierenden Fehlerraten auf der Applikationsebene herleiten und die Plots erzeugen.
  + [X] bitrate - selber messen? keine Doku! ~1 Mbps
    - erreichte rountrip rate: 0.6 ms, gut?
* DONE Unicast reparieren
* TODO Code verschönern [44%]
** TODO ESP IDE Optimierunge:n
- [ ] SDK macht wohl doch einen Unterschied!
- [ ] Optimierung:
  DISABLE BOTH Components => Wi-Fi => "WiFi AMPDU TX" & "WiFi AMPDU RX"
  https://www.esp32.com/viewtopic.php?t=9965
** DONE C Structs
- [X] structs sollten bei master und slave gleich aussehen.
  + also entweder den Slave korregieren, sodass er den anderen struct verwendet
  + ODER den Master auf den Slave struct herunterbrechen und hinnehmen, dass der Payload nicht so schön formatiert ist
** TODO maclist.h informationen besser einbinden
- [ ] Get meta information from maclist.h
** TODO Plotten: Latenz/Sendung und Latenz/Payload
** DONE Airtime 100 times Unicast
** DONE Airtime 100 times Broadcast
** TODO MAC in HEX printen
** TODO DEBUG und VERBOSE sinnvoll trennen
+ DEBUG: Schritte die im Flow vorkommen oder explizit davon abweichen
+ VERBOSE: Informationen über den aktuellen zustand
** DONE Feherlmeldung: TXQ_BLOCK=2000 bekämpfen
* DONE Präsentation vorbereiten [2020-12-14]
* DONE Tolja schreiben
* DONE Unicast reparieren
* TODO Package loss fixen
Wenn Pakete zu schnell hintereinander versendet werden, dann führt das zu Paketverlusten. Genaueres habe ich gefinden in der Doku von Espressif
* KILL Telefonkonferenz [2021-11-01 14:00]
* DONE variablen.h anlegen
* DONE GPIO communication packet ackn (UART)
1) UART
   - 1 to 1
   - asynchronous
   - 2 wires
   - just 20Kbps
   - acknoledge!
   - 15m distance!!!
2) I2C Bus Protocol
   - just 1m distance
   - 1Mbps!!
   - Bus protocol...
3) SPI
   - Duplex?!
   - 25Mbps!!!
   - 4 wires.....
   - 20cm distance...
The ESP has three UART controllers UART0, UART1 and UART2) use UART1 or 2
here is how to setup uart on the ESP32
https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/uart.html
* TODO Pythonbridge Modul [100%]
** DONE Write python bridge
** DONE Why does it break with the python bridge?!
** DONE Fix Problem with broadcasting now
** DONE [#A] MAC Adressen vom Master/Slave checken!
** DONE Why broadcast cant find peers?!
Solution: broadcast peer wasnt added correctly. Just if a messsage was incomming. So there was a problem, because the slave and the master did it the same way. So no message could be received and no peer could be added and so sended correctly
** DONE Master stürzt beim Neustart ab. Warum?!
Weil der Chip nicht ausreichend Strom beim Neustart bekommt. wtf.
** DONE matadata -> new constants
** DONE send meta info from master to slaves
** DONE Collect data on chip or direct print to serial? Collect Data from Slave?!
No Collect Data over Serial from Master
** DONE Should I use uint16_t or uint32_t instead of uint8_t ?!
ESP32...
Aber ich denke das ist schon okay so.
** DONE Wie unterscheidet der Slave elegant zwischen ~meta~ und ~dmx~ paketen?
- Idee: Durch ein meta flag. verbraucht zwar ein byte, ist beim testen allerdings auch wieder fast egal...
- Idee: Durch Paketlänge. Wenn die maximale Paketlänge auf 250 begrenzt ist, meta aber immer 251 nimmt. Dann kann gleich anhand der Paketgröße das Paket eingeordnet werden.
** DONE Sendet Master richtig? Empfängt Slave vollständig?
** DONE Is uint16_t a problem?
there is a cast in the sendMetaAsBroadcast function to uint8_t, this could cause problems
Idee: es könnte eine Lösung sein, werte nur bis 255 zu übergeben, weil die Zahl der Millisekunden eh groß genug sein wird.
Lösung: Nein, es ist kein Problem!
** DONE stupid newline bug
immer eine leere Zeile nach jedem Print...
* DONE Understand addPeer and addToPeerList in utlis.ino
- vielleicht hilft eine Funktion, die die gesamte Peerlist ausgibt?!
* DONE change esp_now_register_recv_cb in Abhängigkeit von Unicast/broadcast
Einfach UnicastSetup erneut ausführen?
* DONE Degbug C header chaos
* TODO find related work
* DONE Tolja Mail schreiben
* TODO Espressif Mail schicken?
* DONE dynamic struct
Wenn ich daten verschicke, dann sollen die Pakete natürlich nicht immer MAX_LENGTH haben, deswgen darf das struct nicht direkt so groß angelegt werden.
Lösung: Einfach die Länge des zu übertragenden Signals beschneiden und +1 rechnen
* DONE Extend unicast to work with pythonbridge
* DONE unicast repair sending length
vielleicht einfach mal alles vereinfachen?
* DONE SendMetaInformation AS unicast
Dann kann für broadcast gleich die gefragte id übermittelt werden, aber ich sehe gerade, dass ich das auch schon so machen wollte...
* DONE Split stupid unicast struct
ein Array in dem die Macaddressen gespeichert sind, durch über das iteriert werden kann und eins in dem die Fakedaten gespeichert sind - kann doch nicht so schwer sein!
- in der Funktion master unicast
* TODO Rework Slave Broadcast&Unicast all in one
* DONE !!!BUG!!! isbroadcasting state problem
Wenn isbroadcasting auf 0 gestetzt ist funktioniert es nicht
Wenn isbroadcasting auf 1 gestetz ist funktioniert es
danach funktioniert auch is broadcasting auf 0.
Warum?
*Lösung*: Das Problem war, dass als sendeaddresse die broadcast addresse genommen wurde, die ist erst bekannt, wenn ein setup broadcast ausgeführt wurde...
* DONE !BUG! unicast wont work
* DONE Master ISBRADCAST 0 first BUG
wennn der Master nicht ISBROADCAST 1 zu beginn ausführt, dann kommt es zum fehler,
die pakete werden zwar gesendet, sind aber noch alle mit 0 initialisiert
Idee: der unicast benutzt gerade das broadcast frame, das existiert zu diesem zeitpunkt allerdings noch nicht
* DONE Parameterize slaveCount for the pythonbridge modul
in der unicastmaster:74 läuft etwas falsch
- was bedeutet die variable slaveCount und warum wird sie nicht vom pythonmodul verteilt
- wie sollen die Daten generell verteilt werden?
  z.B.: ein unicastroundtrip mit jeweils 20 Byts
* DONE WAIT_AFTER_SEND uint16_t?
Ich glaube ich muss den Wert vergrößern, es sei denn es ists beim Testen nicht notwendig
* TODO advanced_Meta_struct instead of MACLIST constansts
das struct in dem alle Werte drin stehen könnte auch genommen werden um diese Werte zu benutzen.
Dann wäre ein Aufruf zb: meta.broadcastId anstelle von BROADCASTID, dann muss es nicht zweimal gemacht werden
* DONE der slave scheint immer korrekte pakete zu empfangen
* TODO Serial to Python Plot
https://makersportal.com/blog/2018/2/25/python-datalogger-reading-the-serial-output-from-arduino-to-analyze-data-using-pyserial
* DONE usefull bitrate vs peak bitrate
* TODO Wireshark Messung vornehmen
Kanalzeit berechnen und zwar nicht mit send vs onDataSend.
Vielleicht eher mit UART?
* DONE RapidRepition
Mache ich das überhaupt? Ist das nicht eher RapidDiscarding?
* DONE SuccessRatio for multiple Slaves
** Master
- OnDataRecv Callback
** Slave
- Erstellt ein Array, in das die richtig angekommenden Nachrichten ausgewertet werden
* DONE Fix Wired SuccessRatioArray Flag on SuccessRatio[1]
